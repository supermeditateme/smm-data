{"version":3,"file":"edfHeader.js","sources":["../../../../../js/lib/core/edf/edfHeader.js"],"sourcesContent":["const HEADER_SPEC = {\n  version: { size: 8, type: 'int' },\n  patientId: { size: 80, type: 'string' },\n  recordingId: { size: 80, type: 'string' },\n  recordingStartDate: { size: 8, type: 'string' },\n  recordingStartTime: { size: 8, type: 'string' },\n  headerSize: { size: 8, type: 'int' },\n  reserved: { size: 44, type: 'binary' },\n  dataRecordsNumber: { size: 8, type: 'int' },\n  dataRecordDuration: { size: 8, type: 'float' },\n  signalsNumber: { size: 4, type: 'int' },\n};\n\nconst SIGNAL_SPEC = {\n  label: { size: 16, type: 'string' },\n  transducerType: { size: 80, type: 'string' },\n  physicalDimension: { size: 8, type: 'string' },\n  physicalMin: { size: 8, type: 'float' },\n  physicalMax: { size: 8, type: 'float' },\n  digitalMin: { size: 8, type: 'int' },\n  digitalMax: { size: 8, type: 'int' },\n  prefiltering: { size: 80, type: 'string' },\n  sampleRate: { size: 8, type: 'int' },\n  reserved: { size: 32, type: 'string' },\n};\n\nexport default class EdfHeader {\n  constructor(stream) {\n    return stream.read(256).then(({ value }) => {\n      const header = this._parseHeader(value);\n      EdfHeader._validateHeader(header);\n      const signalsNumber = header.signalsNumber;\n\n      return stream.read(256 * signalsNumber).then(({ value }) => {\n        header.signals = this._parseSignals(value, signalsNumber);\n        return new Promise(resolve => resolve(header));\n      });\n    });\n  }\n\n  _parseSignals(bytes, signalsNumber) {\n    let result = [];\n\n    for (let signalId = 0; signalId < signalsNumber; signalId++) {\n      const signal = this._parseSignal(bytes, signalId, signalsNumber);\n      EdfHeader._validateSignal(signal);\n      result.push(signal);\n    }\n\n    return result;\n  }\n\n  _parseHeader(bytes) {\n    let result = {};\n    let offset = 0;\n\n    for (const field in HEADER_SPEC) {\n      const fieldSpec = HEADER_SPEC[field];\n      const fieldBytes = bytes.slice(offset, offset + fieldSpec.size);\n      result[field] = this._castValue(fieldBytes, fieldSpec.type);\n      offset += fieldSpec.size;\n    }\n\n    return result;\n  }\n\n  _parseSignal(bytes, signalId, signalsNumber) {\n    let result = {};\n    let offset = 0;\n\n    for (const field in SIGNAL_SPEC) {\n      const fieldSpec = SIGNAL_SPEC[field];\n      const start = offset + signalId * fieldSpec.size;\n      const fieldBytes = bytes.slice(start, start + fieldSpec.size);\n      result[field] = this._castValue(fieldBytes, fieldSpec.type);\n      offset += signalsNumber * fieldSpec.size;\n    }\n\n    return result;\n  }\n\n  _castValue(bytes, type) {\n    const str = new TextDecoder('utf-8').decode(bytes.buffer).trim();\n\n    switch (type) {\n      case 'int':\n        return parseInt(str);\n      case 'float':\n        return parseFloat(str);\n      default:\n        return str;\n    }\n  }\n\n  static _validateHeader(header) {\n    if (header.version !== 0) throw 'Unsupported EDF version';\n\n    if (\n      header.dataRecordsNumber === undefined ||\n      header.dataRecordsNumber < 1 ||\n      header.dataRecordsNumber > 1000000\n    )\n      throw 'Wrong records number';\n\n    if (\n      header.dataRecordDuration === undefined ||\n      header.dataRecordDuration <= 0 ||\n      header.dataRecordDuration > 1000\n    )\n      throw 'Too long record duration';\n\n    if (\n      header.signalsNumber === undefined ||\n      header.signalsNumber < 1 ||\n      header.signalsNumber > 256\n    )\n      throw 'Wrong signals number';\n  }\n\n  static _validateSignal(signal) {\n    if (\n      signal.sampleRate === undefined ||\n      signal.sampleRate < 1 ||\n      signal.sampleRate > 100000\n    )\n      throw 'Wrong sample rate';\n\n    if (signal.physicalMin === undefined) throw 'Wrong physical minimum';\n    if (signal.physicalMax === undefined) throw 'Wrong physical maximum';\n\n    if (signal.digitalMin === undefined) throw 'Wrong digital minimum';\n    if (signal.digitalMax === undefined) throw 'Wrong digital maximum';\n  }\n}\n"],"names":["HEADER_SPEC","size","type","SIGNAL_SPEC","EdfHeader","stream","read","then","value","header","_parseHeader","_validateHeader","signalsNumber","signals","_parseSignals","Promise","resolve","bytes","result","signalId","signal","_parseSignal","_validateSignal","push","offset","field","fieldSpec","fieldBytes","slice","_castValue","start","str","TextDecoder","decode","buffer","trim","parseInt","parseFloat","version","dataRecordsNumber","undefined","dataRecordDuration","sampleRate","physicalMin","physicalMax","digitalMin","digitalMax"],"mappings":"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"}