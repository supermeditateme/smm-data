{"version":3,"file":"Studio.js","sources":["../../../js/lib/Studio.js"],"sourcesContent":["// <Studio> component incapsulates asyncronisity and performance optimizations,\n// and renders a default selection of widgets.\n// It provides a convenient way to use library in full capacity while retaining\n// modularity and flexibility of its modules.\n//\n// More technically, it deals with fetching (and caching) files via network;\n// and enhances the standard exposed store (which is clean and syncronious) with\n// async calculations via webworkers and their cache.\n\nimport React, { Component, Fragment, StrictMode } from 'react';\n// Currently, StrictMode throws warnings about react-redux;\n// see https://github.com/reduxjs/react-redux/issues/897\nimport { createProvider, connect } from 'react-redux';\nimport { createStore } from 'redux';\nimport { STORE_KEY, SEGMENT_DURATION } from './constants';\nimport rootReducer from './reducers';\n\nimport EDFResource from './core/rangeResource';\nimport Cache from './core/exampleCache';\n\nimport { getCurrentSegmentRange } from './selectors';\nimport { setHeader, addDataSegment30s, removeDataSegment30s } from './actions';\n\nimport Viewport from './components/Viewport';\nimport Scroller from './components/TransformScroller';\nimport Ruler from './components/Ruler';\nimport Plot from './components/Plot';\nimport Annotations from './components/Annotations';\nimport SelectedAnnotation from './components/SelectedAnnotation';\nimport ChannelsList from './components/ChannelsList';\nimport AnnotationsMinimap from './components/AnnotationsMinimap';\nimport CtrlClickCatcher from './components/CtrlClickCatcher';\nimport Cursor from './components/Cursor';\n\n// Array equality helper function.\n// Nothing fancy, no support for nested arrays (we don't need it).\nfunction equalArrays(arr1, arr2) {\n  let i = arr1.length;\n  if (i !== arr2.length) {\n    return false;\n  }\n\n  while (i--) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nclass Studio extends Component {\n  constructor(props) {\n    super(props);\n\n    this.cached = null;\n  }\n\n  // handleSegmentChange() implementation depends on the assumption that it's not\n  // debounced or throttled.\n  handleSegmentChange = () => {\n    if (!this.cached) {\n      console.warn('Cache not initialized yet; ignoring update.');\n      return;\n    }\n\n    // Store segmentRange at the start of the request.\n    const currentSegmentRange = this.props.currentSegmentRange;\n\n    this.cached\n      .getChunksAsync(\n        SEGMENT_DURATION * currentSegmentRange[0],\n        SEGMENT_DURATION * currentSegmentRange.length\n      )\n      .then(data => {\n        // Check - segmentRange might have changed (e.g. due to user navigation)\n        // while we were fetching data from cache. In this case, discard data\n        // altogether; there was more recent cache call, it will put proper\n        // data to the store.\n        //\n        // This is not optimal - we might arrange to put to store those parts\n        // of data which *are* in the current segment range. But in this case\n        // deletion becomes a huge problem, so we avoid this, until much\n        // more robust solution is designed.\n        const newerSegmentRange = this.props.currentSegmentRange;\n        if (!equalArrays(newerSegmentRange, currentSegmentRange)) {\n          console.warn(\n            'Segment range has changed while getting data; data discarded'\n          );\n          return;\n        }\n\n        const { data: { rawValues } } = this.props;\n        for (let i = 0; i < rawValues.length; i++) {\n          const iInData = currentSegmentRange.indexOf(i);\n          if (iInData !== -1 && !rawValues[i]) {\n            // Add segment to store if we received it from resource/cache and\n            // don't have it in store already...\n            this.props.dispatch(\n              addDataSegment30s(\n                i,\n                data.slice(\n                  SEGMENT_DURATION * iInData,\n                  SEGMENT_DURATION * iInData + SEGMENT_DURATION\n                )\n              )\n            );\n          } else if (iInData === -1 && rawValues[i]) {\n            // ...otherwise, remove from store. That's essentially garbage\n            // collecting.\n            this.props.dispatch(removeDataSegment30s(i));\n          }\n        }\n      });\n  };\n\n  componentDidMount() {\n    const source = { url: this.props.url };\n    const options =\n      typeof this.props.fetch === 'function'\n        ? { fetch: this.props.fetch }\n        : undefined;\n    const edfResource = new EDFResource(source, options);\n\n    edfResource\n      .fetchHeader()\n      .then(header => {\n        // 1. Get / set header and init cache\n        if (process.env.NODE_ENV === 'development') {\n          console.log('App:header', header);\n        }\n        this.cached = new Cache(edfResource, header);\n        this.props.dispatch(setHeader(header));\n      })\n      .then(() => {\n        // 2. Ask for whatever data we need\n        this.handleSegmentChange();\n      });\n  }\n\n  componentDidUpdate() {\n    this.handleSegmentChange();\n  }\n\n  componentWillUnmount() {\n    this.cached && this.cached.destroy();\n    this.cached = null;\n  }\n\n  render() {\n    const children = this.props.children || (\n      <Fragment>\n        <Scroller>\n          <Ruler />\n          <Viewport>\n            <Annotations />\n            <Plot />\n            <SelectedAnnotation />\n          </Viewport>\n          <Cursor />\n        </Scroller>\n        <CtrlClickCatcher />\n        <ChannelsList />\n        <AnnotationsMinimap />\n      </Fragment>\n    );\n\n    return <div className=\"eegStudio\">{children}</div>;\n  }\n}\n\nconst ConnectedStudio = connect(\n  function mapStateToProps(state) {\n    return {\n      currentSegmentRange: getCurrentSegmentRange(state),\n      data: state.data,\n    };\n  },\n  undefined,\n  undefined,\n  {\n    storeKey: STORE_KEY,\n    areStatePropsEqual: function(next, prev) {\n      // We only care about segmentRange updates.\n      return equalArrays(next.currentSegmentRange, prev.currentSegmentRange);\n    },\n  }\n)(Studio);\n\n// <StudioWrapper> component makes using <Studio> easier from outside.\n//\n// You can either pass store to it directly, or have it connected automatically\n// to existing (properly-keyed) Provider. Will not interfere with the 'main'\n// redux store of an outside app, if it has any.\n\nconst StudioProvider = createProvider(STORE_KEY);\n\nclass StudioWrapper extends Component {\n  constructor(props, context) {\n    super(props, context);\n\n    if (process.env.NODE_ENV === 'development') {\n      if (props.store && context[STORE_KEY]) {\n        console.error(\n          `EEG Studio is given both 'store' prop, and '${STORE_KEY}' context (e.g. wrapped in relevant <Provider>). Choose only one way of connecting!`\n        );\n      }\n    }\n\n    const passedStore = props.store || context[STORE_KEY];\n\n    if (passedStore) {\n      passedStore.replaceReducer(rootReducer);\n      this.store = passedStore;\n    } else {\n      this.store = createStore(rootReducer);\n    }\n  }\n\n  render() {\n    const { store: _, ...otherProps } = this.props;\n\n    return (\n      <StrictMode>\n        <StudioProvider store={this.store}>\n          <ConnectedStudio {...otherProps} />\n        </StudioProvider>\n      </StrictMode>\n    );\n  }\n}\n\nStudioWrapper.contextTypes = {\n  [STORE_KEY]: () => null,\n};\n\nexport default StudioWrapper;\n"],"names":["equalArrays","arr1","arr2","i","length","Studio","props","handleSegmentChange","cached","warn","currentSegmentRange","getChunksAsync","SEGMENT_DURATION","then","newerSegmentRange","rawValues","data","iInData","indexOf","dispatch","addDataSegment30s","slice","removeDataSegment30s","source","url","options","fetch","undefined","edfResource","EDFResource","fetchHeader","process","env","NODE_ENV","log","header","Cache","setHeader","destroy","children","Component","ConnectedStudio","connect","mapStateToProps","state","getCurrentSegmentRange","STORE_KEY","next","prev","StudioProvider","createProvider","StudioWrapper","context","store","error","passedStore","replaceReducer","rootReducer","createStore","_","otherProps","contextTypes"],"mappings":"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"}