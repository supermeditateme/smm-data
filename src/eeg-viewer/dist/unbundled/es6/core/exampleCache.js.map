{"version":3,"file":"exampleCache.js","sources":["../../../../js/lib/core/exampleCache.js"],"sourcesContent":["import deferred from './deferred';\n\n// TODO destruction behaviour +/-\n\nconst MAX_CACHE_SIZE = 2000; // dataRecords. TODO tunable\nconst MAX_REQUEST_SIZE = 500; // dataRecords. TODO tunable\n\nclass ExampleCache {\n  constructor(resource, header, options = { concurrency: 2 }) {\n    if (!resource || !header) {\n      throw new Error('resource or header not supplied to cache constructor');\n    }\n\n    this.resource = resource;\n    this.header = header;\n    this.options = options;\n\n    const totalSize = header.dataRecordsNumber;\n\n    // Actual dataRecords in cache\n    this._data = new Array(totalSize).fill(null);\n    this._dataCount = 0;\n\n    // dataRecord indices that have been requested by user\n    // Each request by user is assigned a sequential number, for cache clearing\n    // later\n    this._requested = new Array(totalSize).fill(null);\n    this._lastRequested = 0;\n\n    // dataRecord indices that are being fetched from the server right now\n    this._fetching = new Array(totalSize).fill(null);\n\n    this.unsubscribeChunk = resource.on(\n      'chunk',\n      (index, dataRecord, requestId) => {\n        this._processNewChunk(index, dataRecord, requestId);\n      }\n    );\n    this.unsubscribeFinish = resource.on('finish', () => {\n      this.scheduleDataRequest();\n    });\n    this.unsubscribeDestroy = resource.on('destroy', () => {\n      this.destroy(false);\n    });\n  }\n\n  getChunksAsync(start, _size) {\n    const totalSize = this.header.dataRecordsNumber;\n\n    if (start < 0 || start > totalSize - 1) {\n      // prettier-ignore\n      throw new Error(\n        `Incorrect start supplied to getChunksAsync(): ${start} (total edf size is ${totalSize})`\n      );\n    }\n\n    const size = Math.min(_size, totalSize - start);\n\n    if (process.env.NODE_ENV === 'development') {\n      if (size < _size) {\n        // prettier-ignore\n        console.log(\n          `getChunksAsync(${start}, ${_size}): requested chunks past edf file boundary (${totalSize}); truncating to getChunksAsync(${start}, ${size}).`\n        );\n      }\n    }\n\n    const requestNumber = ++this._lastRequested;\n    let canGetFromCache = true;\n    let willFetchEventually = true;\n    for (let i = start; i < start + size; i++) {\n      this._requested[i] = requestNumber;\n      canGetFromCache = canGetFromCache && !!this._data[i];\n      willFetchEventually =\n        willFetchEventually && (!!this._data[i] || !!this._fetching[i]);\n    }\n\n    // Simple case - we've got everything we need in cache...\n    if (canGetFromCache) {\n      console.info('full cache hit', start, size);\n      return deferred().resolve(this._data.slice(start, start + size));\n    }\n\n    // ...complex case - we don't have everything.\n    const deferredPromise = deferred((res, rej) => {\n      let collectedChunks = this._data.slice(start, start + size);\n      const unsubscribeChunk = this.resource.on(\n        'chunk',\n        (index, dataRecord) => {\n          if (\n            index < start ||\n            index > start + size - 1 ||\n            !!collectedChunks[index - start]\n          ) {\n            return;\n          }\n          collectedChunks[index - start] = dataRecord;\n\n          if (!collectedChunks.includes(null)) {\n            // All chunks collected; resolve promise with a shallow copy of array.\n            res(collectedChunks.slice());\n            destroy();\n          }\n        }\n      );\n      // TODO FIXME it's faulty implementation. Must be `this.on('destroy'`, not `this.resource.on('destroy'`\n      const unsubscribeDestroy = this.resource.on('destroy', () => {\n        destroy();\n      });\n\n      // To prevent memory leaks, we should clean up everything in regard to\n      // this promise.\n      const destroy = () => {\n        unsubscribeChunk();\n        unsubscribeDestroy();\n        for (let i = 0; i < size; i++) {\n          collectedChunks[i] = null;\n        }\n        collectedChunks = null;\n      };\n    });\n\n    // Are dataRecords that we need being fetched right now? If not, we should\n    // ask resource to load data.\n    if (!willFetchEventually) {\n      this.scheduleDataRequest();\n    }\n\n    return deferredPromise;\n  }\n\n  scheduleDataRequest() {\n    if (this.resource.getRequestCount() >= this.options.concurrency) {\n      // Too many requests already running; do nothing. When any running\n      // request is finished, this function will be called again.\n      return;\n    }\n\n    const totalSize = this.header.dataRecordsNumber;\n    let start = null;\n    let end = null;\n    for (let i = 0; i < totalSize; i++) {\n      if (!this._requested[i] || !!this._data[i] || !!this._fetching[i]) {\n        continue;\n      }\n      if (start === null) {\n        start = i;\n      }\n      end = i;\n    }\n    if (start === null) {\n      return;\n    }\n\n    const size = Math.min(end - start + 1, MAX_REQUEST_SIZE);\n\n    // We may get something other than what we've asked for\n    const [requestId, requestStart, requestSize] = this.resource.loadChunks(\n      start,\n      size\n    );\n    for (let i = requestStart; i < requestSize; i++) {\n      this._fetching[i] = this._fetching[i] || [];\n      this._fetching[i].push(requestId);\n    }\n  }\n\n  _cleanOneChunk() {\n    // Simple implementation, clean only one chunk (make full scan for that).\n    // TODO better\n    const totalSize = this.header.dataRecordsNumber;\n    let lowestGeneration = Infinity;\n    let found = null;\n    for (let i = 0; i < totalSize; i++) {\n      if (!this._data[i] || this._requested[i] >= lowestGeneration) {\n        continue;\n      }\n      lowestGeneration = this._requested[i];\n      found = i;\n    }\n\n    if (found === null) {\n      throw new Error(\n        'Tried to clean one chunk from cache, but found no eligible chunk!'\n      );\n    }\n    if (this._fetching[found]) {\n      throw new Error(\n        'Tried to clean one chunk from cache, but this chunk is being requested!'\n      );\n    }\n\n    this._data[found] = null;\n    this._requested[found] = null;\n    this._dataCount -= 1;\n  }\n\n  _processNewChunk(index, dataRecord, requestId) {\n    if (this._dataCount > MAX_CACHE_SIZE) {\n      this._cleanOneChunk();\n    }\n\n    this._data[index] = dataRecord;\n    this._dataCount += 1;\n\n    // For those chunks that are not explicitly requested by user, we set\n    // their generation number to zero, so that they are cleaned from cache\n    // first.\n    this._requested[index] = this._requested[index] || 0;\n\n    if (!this._fetching[index]) {\n      // Received chunk out of the blue. Do nothing with _fetching[] array.\n    } else if (this._fetching[index].length === 1) {\n      this._fetching[index] = null;\n    } else {\n      const idx = this._fetching[index].indexOf(requestId);\n      if (idx === -1) {\n        throw new Error(\"Mustn't happen\");\n      }\n      this._fetching[index].splice(idx, 1);\n    }\n  }\n\n  destroy(destroyResource = true) {\n    this.unsubscribeChunk();\n    this.unsubscribeFinish();\n    this.unsubscribeDestroy();\n    for (let i = 0; i < this._data.length; i++) {\n      this._data[i] = null;\n    }\n    this._data = null;\n    this._requested = null;\n    this._fetching = null;\n\n    destroyResource && this.resource.destroy();\n  }\n}\n\nexport default ExampleCache;\n"],"names":["MAX_CACHE_SIZE","MAX_REQUEST_SIZE","ExampleCache","resource","header","options","concurrency","Error","totalSize","dataRecordsNumber","_data","Array","fill","_dataCount","_requested","_lastRequested","_fetching","unsubscribeChunk","on","index","dataRecord","requestId","_processNewChunk","unsubscribeFinish","scheduleDataRequest","unsubscribeDestroy","destroy","start","_size","size","Math","min","process","env","NODE_ENV","log","requestNumber","canGetFromCache","willFetchEventually","i","info","deferred","resolve","slice","deferredPromise","res","rej","collectedChunks","includes","getRequestCount","end","loadChunks","requestStart","requestSize","push","lowestGeneration","Infinity","found","_cleanOneChunk","length","idx","indexOf","splice","destroyResource"],"mappings":";;;;;;;;;;AAIA,IAAMA,iBAAiB,IAAvB;AACA,IAAMC,mBAAmB,GAAzB;;IAEMC;wBACQC,QAAZ,EAAsBC,MAAtB,EAA4D;;;QAA9BC,OAA8B,uEAApB,EAAEC,aAAa,CAAf,EAAoB;;;;QACtD,CAACH,QAAD,IAAa,CAACC,MAAlB,EAA0B;YAClB,IAAIG,KAAJ,CAAU,sDAAV,CAAN;;;SAGGJ,QAAL,GAAgBA,QAAhB;SACKC,MAAL,GAAcA,MAAd;SACKC,OAAL,GAAeA,OAAf;;QAEMG,YAAYJ,OAAOK,iBAAzB;;;SAGKC,KAAL,GAAa,IAAIC,KAAJ,CAAUH,SAAV,EAAqBI,IAArB,CAA0B,IAA1B,CAAb;SACKC,UAAL,GAAkB,CAAlB;;;;;SAKKC,UAAL,GAAkB,IAAIH,KAAJ,CAAUH,SAAV,EAAqBI,IAArB,CAA0B,IAA1B,CAAlB;SACKG,cAAL,GAAsB,CAAtB;;;SAGKC,SAAL,GAAiB,IAAIL,KAAJ,CAAUH,SAAV,EAAqBI,IAArB,CAA0B,IAA1B,CAAjB;;SAEKK,gBAAL,GAAwBd,SAASe,EAAT,CACtB,OADsB,EAEtB,UAACC,KAAD,EAAQC,UAAR,EAAoBC,SAApB,EAAkC;YAC3BC,gBAAL,CAAsBH,KAAtB,EAA6BC,UAA7B,EAAyCC,SAAzC;KAHoB,CAAxB;SAMKE,iBAAL,GAAyBpB,SAASe,EAAT,CAAY,QAAZ,EAAsB,YAAM;YAC9CM,mBAAL;KADuB,CAAzB;SAGKC,kBAAL,GAA0BtB,SAASe,EAAT,CAAY,SAAZ,EAAuB,YAAM;YAChDQ,OAAL,CAAa,KAAb;KADwB,CAA1B;;;;;mCAKaC,OAAOC,OAAO;;;UACrBpB,YAAY,KAAKJ,MAAL,CAAYK,iBAA9B;;UAEIkB,QAAQ,CAAR,IAAaA,QAAQnB,YAAY,CAArC,EAAwC;;cAEhC,IAAID,KAAJ,oDAC6CoB,KAD7C,4BACyEnB,SADzE,OAAN;;;UAKIqB,OAAOC,KAAKC,GAAL,CAASH,KAAT,EAAgBpB,YAAYmB,KAA5B,CAAb;;UAEIK,QAAQC,GAAR,CAAYC,QAAZ,KAAyB,aAA7B,EAA4C;YACtCL,OAAOD,KAAX,EAAkB;;kBAERO,GAAR,qBACoBR,KADpB,UAC8BC,KAD9B,oDACkFpB,SADlF,wCAC8HmB,KAD9H,UACwIE,IADxI;;;;UAMEO,gBAAgB,EAAE,KAAKrB,cAA7B;UACIsB,kBAAkB,IAAtB;UACIC,sBAAsB,IAA1B;WACK,IAAIC,IAAIZ,KAAb,EAAoBY,IAAIZ,QAAQE,IAAhC,EAAsCU,GAAtC,EAA2C;aACpCzB,UAAL,CAAgByB,CAAhB,IAAqBH,aAArB;0BACkBC,mBAAmB,CAAC,CAAC,KAAK3B,KAAL,CAAW6B,CAAX,CAAvC;8BAEED,wBAAwB,CAAC,CAAC,KAAK5B,KAAL,CAAW6B,CAAX,CAAF,IAAmB,CAAC,CAAC,KAAKvB,SAAL,CAAeuB,CAAf,CAA7C,CADF;;;;UAKEF,eAAJ,EAAqB;gBACXG,IAAR,CAAa,gBAAb,EAA+Bb,KAA/B,EAAsCE,IAAtC;eACOY,WAAWC,OAAX,CAAmB,KAAKhC,KAAL,CAAWiC,KAAX,CAAiBhB,KAAjB,EAAwBA,QAAQE,IAAhC,CAAnB,CAAP;;;;UAIIe,kBAAkBH,SAAS,UAACI,GAAD,EAAMC,GAAN,EAAc;YACzCC,kBAAkB,OAAKrC,KAAL,CAAWiC,KAAX,CAAiBhB,KAAjB,EAAwBA,QAAQE,IAAhC,CAAtB;YACMZ,mBAAmB,OAAKd,QAAL,CAAce,EAAd,CACvB,OADuB,EAEvB,UAACC,KAAD,EAAQC,UAAR,EAAuB;cAEnBD,QAAQQ,KAAR,IACAR,QAAQQ,QAAQE,IAAR,GAAe,CADvB,IAEA,CAAC,CAACkB,gBAAgB5B,QAAQQ,KAAxB,CAHJ,EAIE;;;0BAGcR,QAAQQ,KAAxB,IAAiCP,UAAjC;;cAEI,CAAC2B,gBAAgBC,QAAhB,CAAyB,IAAzB,CAAL,EAAqC;;gBAE/BD,gBAAgBJ,KAAhB,EAAJ;;;SAdmB,CAAzB;;YAoBMlB,qBAAqB,OAAKtB,QAAL,CAAce,EAAd,CAAiB,SAAjB,EAA4B,YAAM;;SAAlC,CAA3B;;;;YAMMQ,UAAU,SAAVA,OAAU,GAAM;;;eAGf,IAAIa,KAAI,CAAb,EAAgBA,KAAIV,IAApB,EAA0BU,IAA1B,EAA+B;4BACbA,EAAhB,IAAqB,IAArB;;4BAEgB,IAAlB;SANF;OA5BsB,CAAxB;;;;UAwCI,CAACD,mBAAL,EAA0B;aACnBd,mBAAL;;;aAGKoB,eAAP;;;;0CAGoB;UAChB,KAAKzC,QAAL,CAAc8C,eAAd,MAAmC,KAAK5C,OAAL,CAAaC,WAApD,EAAiE;;;;;;UAM3DE,YAAY,KAAKJ,MAAL,CAAYK,iBAA9B;UACIkB,QAAQ,IAAZ;UACIuB,MAAM,IAAV;WACK,IAAIX,IAAI,CAAb,EAAgBA,IAAI/B,SAApB,EAA+B+B,GAA/B,EAAoC;YAC9B,CAAC,KAAKzB,UAAL,CAAgByB,CAAhB,CAAD,IAAuB,CAAC,CAAC,KAAK7B,KAAL,CAAW6B,CAAX,CAAzB,IAA0C,CAAC,CAAC,KAAKvB,SAAL,CAAeuB,CAAf,CAAhD,EAAmE;;;YAG/DZ,UAAU,IAAd,EAAoB;kBACVY,CAAR;;cAEIA,CAAN;;UAEEZ,UAAU,IAAd,EAAoB;;;;UAIdE,OAAOC,KAAKC,GAAL,CAASmB,MAAMvB,KAAN,GAAc,CAAvB,EAA0B1B,gBAA1B,CAAb;;;;iCAG+C,KAAKE,QAAL,CAAcgD,UAAd,CAC7CxB,KAD6C,EAE7CE,IAF6C,CA1B3B;;UA0BbR,SA1Ba;UA0BF+B,YA1BE;UA0BYC,WA1BZ;;WA8Bf,IAAId,MAAIa,YAAb,EAA2Bb,MAAIc,WAA/B,EAA4Cd,KAA5C,EAAiD;aAC1CvB,SAAL,CAAeuB,GAAf,IAAoB,KAAKvB,SAAL,CAAeuB,GAAf,KAAqB,EAAzC;aACKvB,SAAL,CAAeuB,GAAf,EAAkBe,IAAlB,CAAuBjC,SAAvB;;;;;qCAIa;;;UAGTb,YAAY,KAAKJ,MAAL,CAAYK,iBAA9B;UACI8C,mBAAmBC,QAAvB;UACIC,QAAQ,IAAZ;WACK,IAAIlB,IAAI,CAAb,EAAgBA,IAAI/B,SAApB,EAA+B+B,GAA/B,EAAoC;YAC9B,CAAC,KAAK7B,KAAL,CAAW6B,CAAX,CAAD,IAAkB,KAAKzB,UAAL,CAAgByB,CAAhB,KAAsBgB,gBAA5C,EAA8D;;;2BAG3C,KAAKzC,UAAL,CAAgByB,CAAhB,CAAnB;gBACQA,CAAR;;;UAGEkB,UAAU,IAAd,EAAoB;cACZ,IAAIlD,KAAJ,CACJ,mEADI,CAAN;;UAIE,KAAKS,SAAL,CAAeyC,KAAf,CAAJ,EAA2B;cACnB,IAAIlD,KAAJ,CACJ,yEADI,CAAN;;;WAKGG,KAAL,CAAW+C,KAAX,IAAoB,IAApB;WACK3C,UAAL,CAAgB2C,KAAhB,IAAyB,IAAzB;WACK5C,UAAL,IAAmB,CAAnB;;;;qCAGeM,OAAOC,YAAYC,WAAW;UACzC,KAAKR,UAAL,GAAkBb,cAAtB,EAAsC;aAC/B0D,cAAL;;;WAGGhD,KAAL,CAAWS,KAAX,IAAoBC,UAApB;WACKP,UAAL,IAAmB,CAAnB;;;;;WAKKC,UAAL,CAAgBK,KAAhB,IAAyB,KAAKL,UAAL,CAAgBK,KAAhB,KAA0B,CAAnD;;UAEI,CAAC,KAAKH,SAAL,CAAeG,KAAf,CAAL,EAA4B,CAA5B,MAEO,IAAI,KAAKH,SAAL,CAAeG,KAAf,EAAsBwC,MAAtB,KAAiC,CAArC,EAAwC;aACxC3C,SAAL,CAAeG,KAAf,IAAwB,IAAxB;OADK,MAEA;YACCyC,MAAM,KAAK5C,SAAL,CAAeG,KAAf,EAAsB0C,OAAtB,CAA8BxC,SAA9B,CAAZ;YACIuC,QAAQ,CAAC,CAAb,EAAgB;gBACR,IAAIrD,KAAJ,CAAU,gBAAV,CAAN;;aAEGS,SAAL,CAAeG,KAAf,EAAsB2C,MAAtB,CAA6BF,GAA7B,EAAkC,CAAlC;;;;;8BAI4B;UAAxBG,eAAwB,uEAAN,IAAM;;WACzB9C,gBAAL;WACKM,iBAAL;WACKE,kBAAL;WACK,IAAIc,IAAI,CAAb,EAAgBA,IAAI,KAAK7B,KAAL,CAAWiD,MAA/B,EAAuCpB,GAAvC,EAA4C;aACrC7B,KAAL,CAAW6B,CAAX,IAAgB,IAAhB;;WAEG7B,KAAL,GAAa,IAAb;WACKI,UAAL,GAAkB,IAAlB;WACKE,SAAL,GAAiB,IAAjB;;yBAEmB,KAAKb,QAAL,CAAcuB,OAAd,EAAnB;;;;;;;;;"}